// deno-lint-ignore no-explicit-any
type Any = any;

/**
 * Interface which accepts a Source class or object and limits the keys to
 * just functions that return strings. If the Source class or object has
 * other properties that are not functions those will be kept out of the
 * type-safe shape.
 */
type TextSuppliers<Source> = {
  [K in keyof Source]: K extends string ? (
      Source[K] extends (...args: Any[]) => string | string[] ? K : never
    )
    : never;
};

type TextSupplierFnNames<Source> = TextSuppliers<Source>[keyof Source];

function textSupplierFnNames<Source>(
  instance: Source,
  isClass: boolean,
): TextSupplierFnNames<Source>[] {
  const propertyNames = Object.getOwnPropertyNames(
    instance,
  ) as (keyof Source)[];

  // Filter property names based on the type of their corresponding values
  const supplierNames = propertyNames.filter((name) => {
    if (isClass && name == "constructor") return false;

    const potentialFn = instance[name];
    if (typeof potentialFn === "function") {
      // we cannot reflect the actual return type of the function right now
      return true;
    }

    return false;
  });

  return supplierNames as TextSupplierFnNames<Source>[];
}

/**
 * Represents the structure of a SQL page file with path and content.
 */
interface SqlPagesFileRecord {
  /** The identifier or name of the SQL page method. */
  readonly path: string;
  /** The SQL content generated by the method. */
  readonly content: string;
}

/**
 * Defines the type for patterns used to match method names.
 * Can be a string or a RegExp.
 */
type PathPattern = string | RegExp;

/**
 * A source and its paths (usually methods or functions that generate SQL).
 */
interface SourcePaths<T> {
  readonly instance: T;
  readonly paths: TextSupplierFnNames<T>[];
  readonly class?: Any;
}

/**
 * A function type that determines which methods to process based on the PagesSrc instance and patterns.
 */
interface PathContentsSupplier<Source> {
  (
    sp: SourcePaths<Source>,
    includePatterns: PathPattern[],
    excludePatterns: PathPattern[],
  ): TextSupplierFnNames<Source>[];
}

/**
 * A function type that supplies content arguments to SQL methods.
 */
interface ContentsArgsSupplier<
  Source,
  CandidateContentArg extends Any[],
  ContentArg extends Any[],
> {
  (
    sp: SourcePaths<Source>,
    sqlPagePath: string,
    ...candidateArgs: CandidateContentArg
  ): ContentArg;
}

function sourcePaths<T>(candidate: Any, ...args: Any[]): SourcePaths<T> {
  if (typeof candidate === "object") {
    const isClassInstance = candidate.constructor &&
      candidate.constructor !== Object;
    const instanceOf = isClassInstance ? candidate.constructor : undefined;
    return {
      class: instanceOf,
      instance: candidate as T,
      paths: instanceOf
        ? textSupplierFnNames<T>(instanceOf.prototype, true)
        : textSupplierFnNames<T>(candidate, false),
    };
  }

  if (typeof candidate === "function" && candidate.prototype) {
    const instance = new candidate(...args) as T;
    return {
      class: candidate,
      instance,
      paths: textSupplierFnNames<T>(candidate.prototype, true),
    };
  }

  if (typeof candidate === "function") {
    return sourcePaths(candidate(...args), ...args);
  }

  throw new Error(
    "Invalid input: candidate must be an object, class definition, or constructor function",
  );
}

/**
 * SQLPageAide is a utility class designed to facilitate the creation of upsert statements
 * for the SQLPage low-code tool. SQLPage expects a table called `sqlpage_files` with
 * columns `path` and `contents` to define pages that it can serve via HTTP.
 *
 * The `path` column serves as a unique identifier for each page or API endpoint, while the
 * `contents` column holds the SQL statements or other content that define the page's response.
 *
 * SQLPageAide enables developers to use strongly-typed TypeScript objects and classes to
 * define these paths and contents more conveniently and with fewer errors.
 *
 * Key Features:
 * - Structured Definitions: Use TypeScript classes or objects to define SQL page paths and contents.
 * - Strong Typing: Leverage TypeScript's strong typing for consistent and accurate data types and method signatures.
 * - Convenience Functions:
 *   - `sources()`: Specify the classes or objects containing SQL definitions.
 *   - `include()`: Include specific patterns to match method names.
 *   - `exclude()`: Exclude specific patterns from matching method names.
 *   - `withContentsArgs()`: Inject additional context or arguments into SQL methods for dynamic content.
 *   - `pathContents()`: Customize the method selection process for upserting into `sqlpage_files`.
 * - Automatic Upsert Generation:
 *   - `upsertValues()`: Collects and prepares SQL statements for insertion or update.
 *   - `SQL()`: Generates SQL statements to manage entries in the `sqlpage_files` table.
 *
 * Benefits:
 * - Reduced Errors: Catch errors at compile-time with TypeScript, enhancing application robustness.
 * - Easier Maintenance: Structured SQL page definitions improve codebase readability and maintainability.
 * - Flexibility and Control: Full control over SQL page definition and management, with customizable method selection.
 *
 * ## Usage Example
 *
 * ```typescript
 * // Define a class with SQL methods
 * class MySqlPages {
 *     "index.sql"() {
 *         return "SELECT * FROM users;";
 *     }
 *
 *     "page1.sql"() {
 *         return "INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');";
 *     }
 * }
 *
 * // Generate SQL statements
 * console.log(new SQLPageAide(MySqlPages).SQL());
 * // Output:
 * // INSERT INTO sqlpage_files (path, contents, last_modified) VALUES ('index.sql', 'SELECT * FROM users;', CURRENT_TIMESTAMP) ON CONFLICT(path) DO UPDATE SET contents=excluded.contents, last_modified=CURRENT_TIMESTAMP);
 * // INSERT INTO sqlpage_files (path, contents, last_modified) VALUES ('page1.sql', 'INSERT INTO users (name, email) VALUES (''John Doe'', ''john@example.com'');', CURRENT_TIMESTAMP) ON CONFLICT(path) DO UPDATE SET contents=excluded.contents, last_modified=CURRENT_TIMESTAMP);
 * ```
 */
export class SQLPageAide<
  Source,
  CandidateContentArgs extends Any[],
  ContentArgs extends Any[],
> {
  protected sqlPagesSources: SourcePaths<Source>[] = [];
  protected includePatterns: PathPattern[] = [];
  protected excludePatterns: PathPattern[] = [];
  protected contentsArgsSupplier?: ContentsArgsSupplier<
    Source,
    CandidateContentArgs,
    ContentArgs
  >;
  protected pathContentsSupplier: PathContentsSupplier<Source> = (
    sp,
    includePatterns,
    excludePatterns,
  ) => {
    return sp.paths.filter((name) => {
      const matchesInclude = includePatterns.length === 0 ||
        includePatterns.some((pattern) =>
          typeof pattern === "string"
            ? name.includes(pattern)
            : pattern.test(name)
        );
      const matchesExclude = excludePatterns.some((pattern) =>
        typeof pattern === "string"
          ? name.includes(pattern)
          : pattern.test(name)
      );
      return matchesInclude && !matchesExclude;
    });
  };

  /**
   * Creates an instance of SQLPageAide.
   * @param defaultSqlPagesSources - The default SQL pages classes or objects.
   */
  constructor(...defaultSqlPagesSources: Source[]) {
    this.sources(...defaultSqlPagesSources);
  }

  /**
   * Adds SQL pages classes or objects to the instance.
   * If a source is a class (constructor function), it will be instantiated before being added.
   * New sources are appended to the existing list.
   * @param sources - The SQL pages classes or objects.
   * @returns The SQLPageAide instance.
   */
  sources(...sources: Source[]): this {
    this.sqlPagesSources.push(...sources.map((s) => sourcePaths<Source>(s)));
    return this;
  }

  /**
   * Includes specific patterns to match method names.
   * If no patterns are provided, all methods will be considered.
   * @param patterns - The patterns to include method names.
   * @returns The SQLPageAide instance.
   */
  include(...patterns: PathPattern[]): this {
    this.includePatterns = patterns;
    return this;
  }

  /**
   * Excludes specific patterns from matching method names.
   * @param patterns - The patterns to exclude method names.
   * @returns The SQLPageAide instance.
   */
  exclude(...patterns: PathPattern[]): this {
    this.excludePatterns = patterns;
    return this;
  }

  /**
   * Sets the contents arguments supplier function and its arguments.
   * The contents arguments supplier provides additional arguments to the SQL methods.
   * @param contentsArgsSupplier - The contents arguments supplier function.
   * @param contentsArgs - The arguments for the contents supplier.
   * @returns The SQLPageAide instance.
   */
  withContentsArgs(
    contentsArgsSupplier: ContentsArgsSupplier<
      Source,
      CandidateContentArgs,
      ContentArgs
    >,
  ): this {
    this.contentsArgsSupplier = contentsArgsSupplier;
    return this;
  }

  /**
   * Sets the supplier function that determines which methods to process.
   * @param pathContentsSupplier - The supplier function for selecting methods.
   * @returns The SQLPageAide instance.
   */
  pathContents(pathContentsSupplier: PathContentsSupplier<Source>): this {
    this.pathContentsSupplier = pathContentsSupplier;
    return this;
  }

  /**
   * Executes the given path content function, handling the context and arguments.
   * @param source - The source object or class instance containing the method.
   * @param method - The name of the method to call.
   * @param args - The arguments to pass to the method.
   * @returns The SQL result returned by the method (usually string or string[]).
   */
  protected execPathContentsFn(
    sp: SourcePaths<Source>,
    method: TextSupplierFnNames<Source>,
    args?: ContentArgs,
  ) {
    const { instance } = sp;
    if (
      instance &&
      typeof instance === "object" &&
      typeof (instance as Any)[method] === "function"
    ) {
      const fn = (instance as Any)[method] as (...args: Any[]) => unknown;
      return sp.class
        ? (fn.apply(instance, args ? args : []))
        : (args ? fn(...args) : fn());
    }
    return `Method '${String(method)}' not found in source ${instance}`;
  }

  /**
   * Collects all matching SQL statements from the specified methods in the SQL pages.
   * The methods are selected based on the provided include and exclude patterns
   * and the PathContentsSupplier function.
   * If no patterns are provided, all methods in the source are processed.
   *
   * @param args - The arguments to pass to the contents arguments supplier and SQL methods.
   * @returns An array of SQL page files, each containing a path and content.
   */
  upsertValues(...args: CandidateContentArgs): SqlPagesFileRecord[] {
    const upsertFiles: SqlPagesFileRecord[] = [];

    for (const source of this.sqlPagesSources) {
      const methods = this.pathContentsSupplier(
        source,
        this.includePatterns,
        this.excludePatterns,
      );

      for (const method of methods) {
        let sqlStatement: unknown;

        if (this.contentsArgsSupplier) {
          sqlStatement = this.execPathContentsFn(
            source,
            method,
            this.contentsArgsSupplier(source, method, ...args),
          );
        } else {
          sqlStatement = this.execPathContentsFn(source, method);
        }

        if (typeof sqlStatement === "string") {
          upsertFiles.push({ path: method, content: sqlStatement });
        } else if (Array.isArray(sqlStatement)) {
          upsertFiles.push({ path: method, content: sqlStatement.join("\n") });
        } else {
          upsertFiles.push({
            path: method,
            content: `\n/* '${method}' in '${
              String(source.instance)
            }' returned type ${typeof sqlStatement} instead of string or string[] */`,
          });
        }
      }
    }

    return upsertFiles;
  }

  /**
   * Generates SQL statements for upserting into the `sqlpage_files` table.
   * Each SQL statement is a string in an array, representing an individual SQL upsert statement.
   * @param args - The arguments to pass to the contents arguments supplier and SQL methods.
   * @returns An array of SQL statements.
   */
  SQL(...args: CandidateContentArgs): string[] {
    const upsertFiles = this.upsertValues(...args);
    return upsertFiles.map(({ path, content }) => {
      const escapedPath = path.replace(/'/g, "''");
      const escapedContent = content.replace(/'/g, "''");
      return `INSERT INTO sqlpage_files (path, contents, last_modified) VALUES ('${escapedPath}', '${escapedContent}', CURRENT_TIMESTAMP) ON CONFLICT(path) DO UPDATE SET contents=excluded.contents, last_modified=CURRENT_TIMESTAMP);`;
    });
  }
}
