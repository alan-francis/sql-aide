// deno-lint-ignore no-explicit-any
type Any = any;

/**
 * Interface which accepts a Source class or object and limits the keys to
 * just functions that return strings. If the Source class or object has
 * other properties that are not functions those will be kept out of the
 * type-safe shape.
 */
export type TextSuppliers<Source> = {
  [K in keyof Source]: K extends string ? (
      Source[K] extends (...args: Any[]) => string | string[] ? K : never
    )
    : never;
};

export type TextSupplierFnNames<Source> = TextSuppliers<Source>[keyof Source];

export function textSupplierFnNames<Source>(
  instance: Source,
  isClass: boolean,
): TextSupplierFnNames<Source>[] {
  const propertyNames = Object.getOwnPropertyNames(
    instance,
  ) as (keyof Source)[];

  // Filter property names based on the type of their corresponding values
  const supplierNames = propertyNames.filter((name) => {
    if (isClass && name == "constructor") return false;

    const potentialFn = instance[name];
    if (typeof potentialFn === "function") {
      // we cannot reflect the actual return type of the function right now
      return true;
    }

    return false;
  });

  return supplierNames as TextSupplierFnNames<Source>[];
}

/**
 * Represents the structure of a SQL page file with path and content.
 */
export interface SqlPagesFileRecord<Source> {
  /** The identifier or name of the SQL page method. */
  readonly path: string;
  /** The SQL content generated by the method. */
  readonly content: string;
  /** where the SPFR was generated from */
  readonly source: SourcePaths<Source>;
  /** the method that generated the content */
  readonly method: TextSupplierFnNames<Source>;
}

/**
 * Defines the type for patterns used to match method names.
 * Can be a string or a RegExp.
 */
export type PathPattern = string | RegExp;

/**
 * A source and its paths (usually methods or functions that generate SQL).
 */
export interface SourcePaths<T> {
  readonly instance: T;
  readonly paths: TextSupplierFnNames<T>[];
  readonly class?: Any;
}

/**
 * A function type that determines which methods to process based on the PagesSrc instance and patterns.
 */
export interface PathContentsSupplier<Source> {
  (
    sp: SourcePaths<Source>,
    includePatterns: PathPattern[],
    excludePatterns: PathPattern[],
  ): TextSupplierFnNames<Source>[];
}

/**
 * A function type that supplies content arguments to SQL methods.
 */
export interface ContentsArgsSupplier<
  Source,
  CandidateContentArgs extends Any[],
  ContentArgs extends Any[],
> {
  (
    sp: SourcePaths<Source>,
    sqlPagePath: string,
    ...candidateArgs: CandidateContentArgs
  ): ContentArgs;
}

/**
 * A function type that supplies a SQL handler when a SQL method returns something
 * other than a string or string[]
 */
export interface UnknownContentsTypeHandler<
  Source,
  ContentArgs extends Any[],
> {
  (
    contentsResult: unknown,
    sp: SourcePaths<Source>,
    sqlPagePath: string,
    args?: ContentArgs,
  ): string;
}

export function sourcePaths<T>(candidate: Any, ...args: Any[]): SourcePaths<T> {
  if (typeof candidate === "object") {
    const isClassInstance = candidate.constructor &&
      candidate.constructor !== Object;
    const instanceOf = isClassInstance ? candidate.constructor : undefined;
    return {
      class: instanceOf,
      instance: candidate as T,
      paths: instanceOf
        ? textSupplierFnNames<T>(instanceOf.prototype, true)
        : textSupplierFnNames<T>(candidate, false),
    };
  }

  if (typeof candidate === "function" && candidate.prototype) {
    const instance = new candidate(...args) as T;
    return {
      class: candidate,
      instance,
      paths: textSupplierFnNames<T>(candidate.prototype, true),
    };
  }

  if (typeof candidate === "function") {
    return sourcePaths(candidate(...args), ...args);
  }

  throw new Error(
    "Invalid input: candidate must be an object, class definition, or constructor function",
  );
}

/**
 * SQLPageAide is a utility class designed to facilitate the creation of upsert statements
 * for the SQLPage low-code tool. SQLPage expects a table called `sqlpage_files` with
 * columns `path` and `contents` to define pages that it can serve via HTTP.
 *
 * The `path` column serves as a unique identifier for each page or API endpoint, while the
 * `contents` column holds the SQL statements or other content that define the page's response.
 *
 * SQLPageAide enables developers to use strongly-typed TypeScript objects and classes to
 * define these paths and contents more conveniently and with fewer errors.
 *
 * Key Features:
 * - Structured Definitions: Use TypeScript classes or objects to define SQL page paths and contents.
 * - Strong Typing: Leverage TypeScript's strong typing for consistent and accurate data types and method signatures.
 * - Convenience Functions:
 *   - `sources()`: Specify the classes or objects containing SQL definitions.
 *   - `include()`: Include specific patterns to match method names.
 *   - `exclude()`: Exclude specific patterns from matching method names.
 *   - `withContentsArgs()`: Inject additional context or arguments into SQL methods for dynamic content.
 *   - `pathContents()`: Customize the method selection process for upserting into `sqlpage_files`.
 * - Automatic Upsert Generation:
 *   - `upsertValues()`: Collects and prepares SQL statements for insertion or update.
 *   - `SQL()`: Generates SQL statements to manage entries in the `sqlpage_files` table.
 *
 * Benefits:
 * - Reduced Errors: Catch errors at compile-time with TypeScript, enhancing application robustness.
 * - Easier Maintenance: Structured SQL page definitions improve codebase readability and maintainability.
 * - Flexibility and Control: Full control over SQL page definition and management, with customizable method selection.
 *
 * ## Usage Example
 *
 * ```typescript
 * // Define a class with SQL methods
 * class MySqlPages {
 *     "index.sql"() {
 *         return "SELECT * FROM users;";
 *     }
 *
 *     "page1.sql"() {
 *         return "INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');";
 *     }
 * }
 *
 * // Generate SQL statements
 * console.log(new SQLPageAide(MySqlPages).SQL());
 * // Output:
 * // INSERT INTO sqlpage_files (path, contents, last_modified) VALUES ('index.sql', 'SELECT * FROM users;', CURRENT_TIMESTAMP) ON CONFLICT(path) DO UPDATE SET contents=excluded.contents, last_modified=CURRENT_TIMESTAMP);
 * // INSERT INTO sqlpage_files (path, contents, last_modified) VALUES ('page1.sql', 'INSERT INTO users (name, email) VALUES (''John Doe'', ''john@example.com'');', CURRENT_TIMESTAMP) ON CONFLICT(path) DO UPDATE SET contents=excluded.contents, last_modified=CURRENT_TIMESTAMP);
 * ```
 */
export class SQLPageAide<
  Source,
  CandidateContentArgs extends Any[],
  ContentArgs extends Any[],
  SPFR extends SqlPagesFileRecord<Source>,
> {
  protected formattedSQL = false;
  protected sqlPagesSources: SourcePaths<Source>[] = [];
  protected upsertIncludePatterns: PathPattern[] = [];
  protected upsertExcludePatterns: PathPattern[] = [];
  protected sqlIncludePatterns: PathPattern[] = [];
  protected sqlExcludePatterns: PathPattern[] = [];
  protected contentsArgsSupplier?: ContentsArgsSupplier<
    Source,
    CandidateContentArgs,
    ContentArgs
  >;
  protected defaultContentsArgs?: ContentArgs;
  protected constructSPFR?: (
    init: Pick<SqlPagesFileRecord<Source>, "path" | "content">,
    method: TextSupplierFnNames<Source>,
    sp: SourcePaths<Source>,
  ) => SPFR;
  protected refineSPFR?: (value: SPFR, index: number, array: SPFR[]) => SPFR;
  protected unknownUpsertContentsTypeHandler?: UnknownContentsTypeHandler<
    Source,
    ContentArgs
  >;
  protected unknownSqlStmtTypeHandler?: UnknownContentsTypeHandler<
    Source,
    ContentArgs
  >;
  protected sqlStmtsSupplier: PathContentsSupplier<Source> = (
    sp,
    includePatterns,
    excludePatterns,
  ) => {
    return sp.paths.filter((name) => {
      const matchesInclude = includePatterns.some((pattern) =>
        typeof pattern === "string"
          ? name.includes(pattern)
          : pattern.test(name)
      );
      const matchesExclude = excludePatterns.some((pattern) =>
        typeof pattern === "string"
          ? name.includes(pattern)
          : pattern.test(name)
      );
      return matchesInclude && !matchesExclude;
    });
  };
  protected upsertPathContentsSupplier: PathContentsSupplier<Source> = (
    sp,
    includePatterns,
    excludePatterns,
  ) => {
    return sp.paths.filter((name) => {
      const matchesInclude = includePatterns.some((pattern) =>
        typeof pattern === "string"
          ? name.includes(pattern)
          : pattern.test(name)
      );
      const matchesExclude = excludePatterns.some((pattern) =>
        typeof pattern === "string"
          ? name.includes(pattern)
          : pattern.test(name)
      );
      return matchesInclude && !matchesExclude;
    });
  };

  /**
   * Creates an instance of SQLPageAide.
   * @param defaultSqlPagesSources - The default SQL pages classes or objects.
   */
  constructor(...defaultSqlPagesSources: Source[]) {
    this.sources(...defaultSqlPagesSources);
  }

  emitformattedSQL(formatted = true) {
    this.formattedSQL = formatted;
    return this;
  }

  /**
   * Adds SQL pages classes or objects to the instance.
   * If a source is a class (constructor function), it will be instantiated before being added.
   * New sources are appended to the existing list.
   * @param sources - The SQL pages classes or objects.
   * @returns The SQLPageAide instance.
   */
  sources(...sources: Source[]): this {
    this.sqlPagesSources.push(...sources.map((s) => sourcePaths<Source>(s)));
    return this;
  }

  /**
   * Includes specific patterns to match method names which will be upserted
   * into sqlpage_files table.
   * If no patterns are provided, all methods will be considered.
   * @param patterns - The patterns to include method names.
   * @returns The SQLPageAide instance.
   */
  includeUpserts(...patterns: PathPattern[]): this {
    this.upsertIncludePatterns = patterns;
    return this;
  }

  /**
   * Excludes specific patterns from matching method names whose function results
   * will be upserted into sqlpage_files table.
   * @param patterns - The patterns to exclude method names.
   * @returns The SQLPageAide instance.
   */
  excludeUpserts(...patterns: PathPattern[]): this {
    this.upsertExcludePatterns = patterns;
    return this;
  }

  /**
   * Includes specific patterns to match method names which will be injected
   * as SQL before upserting into sqlpage_files.
   * If no patterns are provided, all methods will be considered.
   * @param patterns - The patterns to include method names.
   * @returns The SQLPageAide instance.
   */
  includeSql(...patterns: PathPattern[]): this {
    this.sqlIncludePatterns = patterns;
    return this;
  }

  /**
   * Excludes specific patterns to match method names which will be injected
   * as SQL before upserting into sqlpage_files.
   * @param patterns - The patterns to exclude method names.
   * @returns The SQLPageAide instance.
   */
  excludeSql(...patterns: PathPattern[]): this {
    this.sqlExcludePatterns = patterns;
    return this;
  }
  /**
   * Sets the default contents arguments passed to each SQL Method.
   * @param contentsArgs - The contents arguments supplier function.
   * @returns The SQLPageAide instance.
   */
  withContentsArgs(contentsArgs?: ContentArgs): this {
    this.defaultContentsArgs = contentsArgs;
    return this;
  }

  /**
   * Sets the contents arguments supplier function and its arguments.
   * The contents arguments supplier provides additional arguments to the SQL methods.
   * @param contentsArgsSupplier - The contents arguments supplier function.
   * @returns The SQLPageAide instance.
   */
  withContentsArgsSupplier(
    contentsArgsSupplier: ContentsArgsSupplier<
      Source,
      CandidateContentArgs,
      ContentArgs
    >,
  ): this {
    this.contentsArgsSupplier = contentsArgsSupplier;
    return this;
  }

  /**
   * Sets the contents handler function if the SQL methods return non-string result.
   * @param handler - The contents arguments supplier function.
   * @param contentsArgs - The arguments for the contents supplier.
   * @returns The SQLPageAide instance.
   */
  onNonStringUpsertContents(
    handler: UnknownContentsTypeHandler<Source, ContentArgs>,
  ): this {
    this.unknownUpsertContentsTypeHandler = handler;
    return this;
  }

  /**
   * Sets the contents handler function if the SQL methods return non-string result.
   * @param handler - The contents arguments supplier function.
   * @param contentsArgs - The arguments for the contents supplier.
   * @returns The SQLPageAide instance.
   */
  onNonStringSqlStmt(
    handler: UnknownContentsTypeHandler<Source, ContentArgs>,
  ): this {
    this.unknownSqlStmtTypeHandler = handler;
    return this;
  }

  /**
   * Sets the supplier function that determines which methods to process for
   * providing upsert SQL contents.
   * @param pathContentsSupplier - The supplier function for selecting methods.
   * @returns The SQLPageAide instance.
   */
  upsertPathContents(pathContentsSupplier: PathContentsSupplier<Source>): this {
    this.upsertPathContentsSupplier = pathContentsSupplier;
    return this;
  }

  /**
   * Sets the function which can take the components of an initial SqlPageFileRecord
   * and construct a special type-safe version.
   * @param spfrConstructor the constructor used by upsertFiles()
   */
  withSqlPagesFileRecordConstructor(
    spfrConstructor?: SQLPageAide<
      Source,
      CandidateContentArgs,
      ContentArgs,
      SPFR
    >["constructSPFR"],
  ) {
    this.constructSPFR = spfrConstructor;
    return this;
  }

  /**
   * Sets the supplier function which can transform or "refine" a SqlPageFileRecord
   * before its SQL is emitted. This method allows modification of the content by
   * returning a replacement for any given SqlPagesFileRecord (SPFR).
   * @param spfrTransfomer the upsertFiles.map() transformer function
   */
  withSqlPagesFileRecordTransformer(
    spfrTransfomer?: SQLPageAide<
      Source,
      CandidateContentArgs,
      ContentArgs,
      SPFR
    >["refineSPFR"],
  ) {
    this.refineSPFR = spfrTransfomer;
    return this;
  }

  /**
   * Sets the supplier function that determines which methods to process for
   * SQL statements before upserting into sqlpage_files.
   * @param sqlStmtsSupplier - The supplier function for selecting methods.
   * @returns The SQLPageAide instance.
   */
  sqlStatementsSupplier(sqlStmtsSupplier: PathContentsSupplier<Source>): this {
    this.sqlStmtsSupplier = sqlStmtsSupplier;
    return this;
  }

  /**
   * Executes the given path content function, handling the context and arguments.
   * @param source - The source object or class instance containing the method.
   * @param method - The name of the method to call.
   * @param args - The arguments to pass to the method.
   * @returns The SQL result returned by the method (usually string or string[]).
   */
  protected execPathContentsFn(
    sp: SourcePaths<Source>,
    method: TextSupplierFnNames<Source>,
    args?: ContentArgs,
  ) {
    const { instance } = sp;
    if (
      instance &&
      typeof instance === "object" &&
      typeof (instance as Any)[method] === "function"
    ) {
      const fn = (instance as Any)[method] as (...args: Any[]) => unknown;
      return sp.class
        ? (fn.apply(instance, args ? args : []))
        : (args ? fn(...args) : fn());
    }
    return `Method '${String(method)}' not found in source ${instance}`;
  }

  /**
   * Collects all matching SQL statements from the specified methods.
   * The methods are selected based on the provided include and exclude patterns
   * and the PathContentsSupplier function.
   * If no patterns are provided, no methods in the source are processed.
   *
   * @param args - The arguments to pass to the contents arguments supplier and SQL methods.
   * @returns An array of SQL page files, each containing a path and content.
   */
  sqlStmts(...args: CandidateContentArgs): string[] {
    const sqlStmts: string[] = [];

    for (const source of this.sqlPagesSources) {
      const methods = this.sqlStmtsSupplier(
        source,
        this.sqlIncludePatterns,
        this.sqlExcludePatterns,
      );

      for (const method of methods) {
        let sqlStatement: unknown;

        if (this.contentsArgsSupplier) {
          sqlStatement = this.execPathContentsFn(
            source,
            method,
            this.contentsArgsSupplier(source, method, ...args),
          );
        } else {
          sqlStatement = this.execPathContentsFn(
            source,
            method,
            this.defaultContentsArgs,
          );
        }

        if (typeof sqlStatement === "string") {
          sqlStmts.push(sqlStatement);
        } else if (Array.isArray(sqlStatement)) {
          sqlStmts.push(sqlStatement.join("\n"));
        } else if (this.unknownSqlStmtTypeHandler) {
          const ucthArgs = this.contentsArgsSupplier
            ? this.contentsArgsSupplier(source, method, ...args)
            : this.defaultContentsArgs;
          sqlStmts.push(this.unknownSqlStmtTypeHandler(
            sqlStatement,
            source,
            method,
            ucthArgs,
          ));
        } else {
          sqlStmts.push(
            `\n/* '${method}' in '${
              String(source.instance)
            }' returned type ${typeof sqlStatement} instead of string or string[] */`,
          );
        }
      }
    }

    return sqlStmts;
  }

  /**
   * Collects all matching SQL statements from the specified methods in the sources.
   * The methods are selected based on the provided include and exclude patterns
   * and the PathContentsSupplier function.
   *
   * If no patterns are provided, all methods that look like "*.sql"() in the source
   * are processed.
   *
   * @param args - The arguments to pass to the contents arguments supplier and SQL methods.
   * @returns An array of SQL page files, each containing a path and content.
   */
  upsertValues(...args: CandidateContentArgs): SPFR[] {
    const constructSPFR = this.constructSPFR ??
      ((init, method, source) => ({ ...init, method, source } as SPFR));
    const upsertFiles: SPFR[] = [];

    for (const source of this.sqlPagesSources) {
      const methods = this.upsertPathContentsSupplier(
        source,
        this.upsertIncludePatterns.length == 0
          ? [/.sql$/]
          : this.upsertIncludePatterns,
        this.upsertExcludePatterns,
      );

      for (const method of methods) {
        let sqlStatement: unknown;

        if (this.contentsArgsSupplier) {
          sqlStatement = this.execPathContentsFn(
            source,
            method,
            this.contentsArgsSupplier(source, method, ...args),
          );
        } else {
          sqlStatement = this.execPathContentsFn(
            source,
            method,
            this.defaultContentsArgs,
          );
        }

        if (typeof sqlStatement === "string") {
          upsertFiles.push(
            constructSPFR(
              { path: method, content: sqlStatement },
              method,
              source,
            ),
          );
        } else if (Array.isArray(sqlStatement)) {
          upsertFiles.push(
            constructSPFR(
              { path: method, content: sqlStatement.join("\n") },
              method,
              source,
            ),
          );
        } else if (this.unknownUpsertContentsTypeHandler) {
          const ucthArgs = this.contentsArgsSupplier
            ? this.contentsArgsSupplier(source, method, ...args)
            : this.defaultContentsArgs;
          upsertFiles.push(constructSPFR(
            {
              path: method,
              content: this.unknownUpsertContentsTypeHandler(
                sqlStatement,
                source,
                method,
                ucthArgs,
              ),
            },
            method,
            source,
          ));
        } else {
          upsertFiles.push(constructSPFR(
            {
              path: method,
              content: `\n/* '${method}' in '${
                String(source.instance)
              }' returned type ${typeof sqlStatement} instead of string or string[] */`,
            },
            method,
            source,
          ));
        }
      }
    }

    // return the refined content or original
    return this.refineSPFR ? upsertFiles.map(this.refineSPFR) : upsertFiles;
  }

  /**
   * Generates SQL statements for upserting into the `sqlpage_files` table.
   * Each SQL statement is a string in an array, representing an individual SQL upsert statement.
   * @param args - The arguments to pass to the contents arguments supplier and SQL methods.
   * @returns An array of SQL statements.
   */
  SQL(...args: CandidateContentArgs): string[] {
    const upsertFiles = this.upsertValues(...args);
    return [
      ...this.sqlStmts(...args),
      ...upsertFiles.map(({ path, content }) => {
        const escapedPath = path.replace(/'/g, "''");
        const escapedContent = content.replace(/'/g, "''");
        return this.formattedSQL == false
          ? `INSERT INTO sqlpage_files (path, contents, last_modified) VALUES ('${escapedPath}', '${escapedContent}', CURRENT_TIMESTAMP) ON CONFLICT(path) DO UPDATE SET contents = EXCLUDED.contents, last_modified = CURRENT_TIMESTAMP;`
          : `INSERT INTO sqlpage_files (path, contents, last_modified) VALUES (\n      '${escapedPath}',\n      '${escapedContent}',\n      CURRENT_TIMESTAMP)\n  ON CONFLICT(path) DO UPDATE SET contents = EXCLUDED.contents, last_modified = CURRENT_TIMESTAMP;`;
      }),
    ];
  }
}
