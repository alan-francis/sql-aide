#!/usr/bin/env -S deno run --allow-all

import {
  govnPattern,
  persistContent as pc,
  pgSQLa,
  SQLa,
  zod as z,
} from "./deps.ts";
import * as pgdcp from "./pgdcp.ts";

export class PgDcpVersion {
  protected constructor() {}

  readonly state = pgdcp.pgDcpState(import.meta, {
    subjectArea: "version",
    schemas: ["dcp_extensions", "dcp_lib", "dcp_lifecycle"],
  });
  readonly ctx = SQLa.typicalSqlEmitContext({
    sqlDialect: SQLa.postgreSqlDialect(),
  });
  readonly governedDomains = new govnPattern.GovernedDomains<
    SQLa.SqlDomainQS,
    SQLa.SqlDomainsQS<SQLa.SqlDomainQS>,
    SQLa.SqlEmitContext
  >();

  content() {
    const { ec, schemas } = this.state;
    const dcpLcSchema = SQLa.sqlSchemaDefn("dcp_lifecycle", {
      isIdempotent: true,
    });

    const versionSql = pgSQLa.storedFunction(
      "version_sql",
      {
        schemaName: z.string(),
        versionTableName: z.string(),
        versionedItemColName: z.string(),
        defaultCtx: z.string(),
        initVersion: this.governedDomains.semver(),
      },
      "TEXT",
      (name, args) => pgSQLa.typedPlPgSqlBody(name, args, this.ctx),
      {
        embeddedStsOptions: SQLa.typicalSqlTextSupplierOptions(),
        autoBeginEnd: false,
        isIdempotent: true,
        sqlNS: schemas[2],
        headerBodySeparator: "$version_sql$",
      },
    )`
    return format($execBody$
      SET search_path TO %1$s, dcp_lifecycle, dcp_lib, dcp_extensions;

      CREATE TABLE IF NOT EXISTS %1$s.%2$s_store(
          id integer GENERATED BY DEFAULT AS IDENTITY,
          nature ltree NOT NULL,
          context ltree,
          %3$s_path ltree NOT NULL,
          %3$s text NOT NULL,
          version semver NOT NULL,
          description text,
          labels text[],
          %3$s_elaboration jsonb,
          meta_data jsonb,
          created_at timestamp with time zone NOT NULL default current_date,
          created_by name NOT NULL default current_user,
          CONSTRAINT %2$s_identity UNIQUE(id),
          CONSTRAINT %2$s_unq_row UNIQUE(nature, context, %3$s_path, %3$s, version)
      );
      CREATE INDEX IF NOT EXISTS %2$s_store_nature_idx ON %1$s.%2$s_store USING gist (nature);
      CREATE INDEX IF NOT EXISTS %2$s_store_context_idx ON %1$s.%2$s_store USING gist (context);
      CREATE INDEX IF NOT EXISTS %2$s_store_%3$s_path_idx ON %1$s.%2$s_store USING gist (%3$s_path);
      CREATE INDEX IF NOT EXISTS %2$s_store_%3$s_idx ON %1$s.%2$s_store (%3$s);
      CREATE INDEX IF NOT EXISTS %2$s_store_version_idx ON %1$s.%2$s_store (version);
      CREATE INDEX IF NOT EXISTS %2$s_store_version_hash_idx ON %1$s.%2$s_store USING hash (version);
      CREATE INDEX IF NOT EXISTS %2$s_store_labels_idx ON %1$s.%2$s_store USING gin (labels);

      -- TODO: add, optionally, %1$s.%2$s_pg_relationship table to connect %1$s.%2$s_store record
      --       to PostgreSQL object catalogs; that way, we can tie the official catalog to specific
      --       versions as well
      -- TODO: add, optionally, %1$s.%2$s_event_relationship table to connect %1$s.%2$s_store record
      --       to an existing event manager row; that way, we can tie an event to a version of something

      CREATE OR REPLACE FUNCTION %1$s.%2$s_initial_revision() RETURNS semver LANGUAGE sql IMMUTABLE PARALLEL SAFE AS 'SELECT ''%5$s''::semver';

      -- TODO: add %1$s.%2$s_next_major, %1$s.%2$s_next_minor, and %1$s.%2$s_next_patch
      -- CREATE FUNCTION %1$s.%2$s_next_major(version semver) RETURNS semver LANGUAGE sql IMMUTABLE PARALLEL SAFE AS '(get_semver_major($1))';

      CREATE OR REPLACE VIEW %1$s.%2$s AS
          select *
            from %1$s.%2$s_store
          order by version, created_at desc;

      CREATE OR REPLACE VIEW %1$s.%2$s_latest AS
          select distinct on (nature, context, %3$s_path, %3$s, max(version)) version, created_at, nature, context, %3$s_path, %3$s
          from %1$s.%2$s_store
          group by version, created_at, nature, context, %3$s_path, %3$s
          order by nature, context, %3$s_path, %3$s, max(version), created_at desc;

      create or replace function %1$s.version_upsert_%2$s() returns trigger as $genBody$
      declare
          %2$sId integer;
      begin
          -- TODO: if nature, context, %3$s already exists in the table, get the most recent record
          -- and increment it
          insert into %1$s.%2$s_store (nature, context, %3$s_path, %3$s, version, description, labels, %3$s_elaboration, meta_data) select
              NEW.nature,
              (CASE WHEN (NEW.context IS NULL) THEN '%4$s' ELSE NEW.context END),
              (CASE WHEN (NEW.%3$s_path IS NULL) THEN NEW.%3$s::ltree ELSE NEW.%3$s_path END),
              (CASE WHEN (NEW.%3$s IS NULL) THEN NEW.%3$s_path::text ELSE NEW.%3$s END),
              NEW.version,
              NEW.description,
              NEW.labels,
              NEW.%3$s_elaboration,
              NEW.meta_data
              on conflict on constraint asset_version_unq_row do nothing
            returning id into %2$sId ;
          return NEW;
      end;
      $genBody$ language plpgsql;

      DO $versionUpsertBody$
      BEGIN
        create trigger version_upsert_%2$s_trigger
        instead of insert on %1$s.%2$s
        for each row execute function %1$s.version_upsert_%2$s();
      EXCEPTION
          WHEN duplicate_object THEN
              RAISE NOTICE 'Trigger already exists. Ignoring...';
      END
      $versionUpsertBody$;

      CREATE OR REPLACE PROCEDURE dcp_lifecycle.version_%1$s_%2$s_destroy_all_objects() AS $genBody$
      BEGIN
          EXECUTE('drop table if exists %1$s.%2$s cascade');
      END;
      $genBody$ LANGUAGE PLPGSQL;
  $execBody$, schemaName, versionTableName, versionedItemColName, defaultCtx, initVersion);
    `;

    const versionConstruct = pgSQLa.storedProcedure(
      "version_construct",
      {
        schemaName: z.string(),
        versionTableName: z.string(),
        versionedItemColName: z.string(),
        defaultCtx: z.string(),
        initVersion: z.string(),
      },
      (name, args, _) => pgSQLa.typedPlPgSqlBody(name, args, this.ctx),
      {
        embeddedStsOptions: SQLa.typicalSqlTextSupplierOptions(),
        autoBeginEnd: false,
        isIdempotent: false,
        sqlNS: dcpLcSchema,
      },
    )`
    -- TODO: register execution in DCP Lifecyle event table
    EXECUTE(version_sql(schemaName, versionTableName, versionedItemColName, defaultCtx, initVersion));
  `;

    const psqlText = ec.SQL()`
      ${ec.psqlHeader}
      ${ec.extnDefns.semver}

      ${versionSql}

      ${versionConstruct}

      `;

    const provenance: pgdcp.SqlFilePersistProvenance = {
      confidentiality: "non-sensitive",
      source: import.meta.url,
    };
    const persistableSQL:
      & pgdcp.SqlFilePersistProvenance
      & pc.PersistableContent<pgdcp.SqlFilePersistProvenance> = {
        ...provenance,
        basename: () => ec.psqlBasename(),
        // deno-lint-ignore require-await
        content: async () => {
          return {
            provenance,
            text: psqlText.SQL(ec.sqlEmitContext()),
          };
        },
      };

    return {
      psqlText,
      provenance,
      persistableSQL,
    };
  }

  static init() {
    return new PgDcpVersion();
  }
}

if (import.meta.main) {
  const postgraphile = PgDcpVersion.init();
  const content = postgraphile.content();
  console.log(content.psqlText.SQL(postgraphile.state.ec.sqlEmitContext()));
}
