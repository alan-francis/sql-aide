#!/usr/bin/env -S deno run --allow-all

import { persistContent as pc, pgSQLa, SQLa, zod as z } from "./deps.ts";
import * as pgdcp from "./pgdcp.ts";

export class PgDcpEvent {
  protected constructor() {}

  readonly state = pgdcp.pgDcpState(import.meta, {
    subjectArea: "event",
    schemas: ["dcp_lifecycle", "dcp_extensions", "dcp_lib"],
  });
  readonly ctx = SQLa.typicalSqlEmitContext({
    sqlDialect: SQLa.postgreSqlDialect(),
  });

  content() {
    const { ec, schemas } = this.state;
    const extnLtree = ec.extnDefns.ltree;
    const extnSemver = ec.extnDefns.semver;
    const dcpLcSchema = SQLa.sqlSchemaDefn("dcp_lifecycle", {
      isIdempotent: true,
    });

    const eventManagerSql = pgSQLa.storedFunction(
      "event_manager_sql",
      {
        schemaName: z.string(),
        eventTableName: z.string(),
        eventColName: z.string(),
        defaultCtx: z.string(),
      },
      "TEXT",
      (name, args) => pgSQLa.typedPlPgSqlBody(name, args, this.ctx),
      {
        embeddedStsOptions: SQLa.typicalSqlTextSupplierOptions(),
        autoBeginEnd: false,
        isIdempotent: true,
        sqlNS: schemas[0],
        headerBodySeparator: "$event_manager_sql$",
      },
    )`return format($execBody$
      SET search_path TO %1$s, dcp_lifecycle, dcp_lib, dcp_extensions;

      CREATE TABLE IF NOT EXISTS %1$s.%2$s_store (
          id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
          nature ltree NOT NULL, -- the type, kind, or nature of the event, depends on context
          context ltree default '%4$s', -- could be tenant, account, or any other "ownership" context
          provenance ltree NOT NULL, -- the stream or human identity of the event source, depends on context and nature
          caption text, -- a human-friendly message associated with the event
          %3$s jsonb, -- elaboration of the event
          meta_data jsonb, -- elaboration of the context, nature, provanance or other meta data
          aliases ltree[], -- symlinks
          versions semver[], -- version meta data
          created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT (now() AT TIME ZONE 'utc') NOT NULL,
          created_by name NOT NULL default current_user
      );
      CREATE INDEX IF NOT EXISTS %2$s_nature_idx ON %1$s.%2$s_store USING gist (nature);
      CREATE INDEX IF NOT EXISTS %2$s_context_idx ON %1$s.%2$s_store USING gist (context);
      CREATE INDEX IF NOT EXISTS %2$s_provenance_idx ON %1$s.%2$s_store USING gist (provenance);
      CREATE INDEX IF NOT EXISTS %2$s_aliases_idx ON %1$s.%2$s_store USING gin (aliases);

      -- TODO: https://identity.foundation/confidential-storage/
      CREATE TABLE IF NOT EXISTS %1$s.%2$s_sensitivity(
          id bigint GENERATED BY DEFAULT AS IDENTITY,
          %2$s_id UUID NOT NULL REFERENCES %1$s.%2$s_store (id),
          sensitivity ltree NOT NULL,
          created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT (now() AT TIME ZONE 'utc') NOT NULL,
          deactivated_at timestamp with time zone,
          updated_at timestamp with time zone,
          deleted_at timestamp with time zone
      );
      CREATE INDEX IF NOT EXISTS %2$s_sensitivity_idx ON %1$s.%2$s_sensitivity USING gist (sensitivity);

      -- the event is stored in %1$s.%2$s_store but accessed through %1$s.%2$s
      CREATE OR REPLACE VIEW %1$s.%2$s AS
      SELECT *
        FROM %1$s.%2$s_store
      ORDER BY created_at desc;

      create or replace function %1$s.event_manager_insert_%2$s() returns trigger as $genBody$
      declare
          %2$sId UUID;
      begin
          insert into %1$s.%2$s_store (context, nature, provenance, caption, %3$s, meta_data, aliases, versions) select
              (CASE WHEN (NEW.context IS NULL) THEN '%4$s' ELSE NEW.context END),
              NEW.nature,
              NEW.provenance,
              NEW.caption,
              NEW.%3$s,
              NEW.meta_data,
              NEW.aliases,
              NEW.versions
              returning id into %2$sId;
          -- TODO: add any other inserts necessary
          -- insert into %1$s.%2$s_sensitivity (%2$s_id, value) select %2$sId, NEW.value;
          return NEW;
      end;
      $genBody$ language plpgsql;

      DO $eventManagerInsertBody$
      BEGIN
      create trigger event_manager_insert_%2$s_trigger
      instead of insert on %1$s.%2$s
      for each row execute function %1$s.event_manager_insert_%2$s();
      EXCEPTION
          WHEN duplicate_object THEN
              RAISE NOTICE 'Trigger already exists. Ignoring...';
      END
      $eventManagerInsertBody$;

      CREATE OR REPLACE PROCEDURE dcp_lifecycle.event_manager_%1$s_%2$s_destroy_all_objects() AS $genBody$
      BEGIN
          EXECUTE('drop view if exists %1$s.%2$s cascade');
          EXECUTE('drop function if exists %1$s.event_manager_insert_%2$s');
          EXECUTE('drop table if exists %1$s.%2$s_sensitivity cascade');
          EXECUTE('drop table if exists %1$s.%2$s cascade');
      END;
      $genBody$ LANGUAGE PLPGSQL;
  $execBody$, schemaName, eventTableName, eventColName, defaultCtx);`;

    const eventManagerConstruct = pgSQLa.storedProcedure(
      "event_manager_construct",
      {
        schemaName: z.string(),
        eventTableName: z.string(),
        eventColName: z.string(),
        defaultCtx: z.string(),
      },
      (name, args, _) => pgSQLa.typedPlPgSqlBody(name, args, this.ctx),
      {
        embeddedStsOptions: SQLa.typicalSqlTextSupplierOptions(),
        autoBeginEnd: false,
        isIdempotent: false,
        sqlNS: dcpLcSchema,
      },
    )`
    -- TODO: register execution in DCP Lifecyle log table
    EXECUTE(event_manager_sql(schemaName, eventTableName, eventColName, defaultCtx));
  `;

    const psqlText = ec.SQL()`
      ${ec.psqlHeader}

      ${schemas}

      ${extnLtree}
      ${extnSemver}

      ${eventManagerSql}

      ${eventManagerConstruct}

      `;

    const provenance: pgdcp.SqlFilePersistProvenance = {
      confidentiality: "non-sensitive",
      source: import.meta.url,
    };
    const persistableSQL:
      & pgdcp.SqlFilePersistProvenance
      & pc.PersistableContent<pgdcp.SqlFilePersistProvenance> = {
        ...provenance,
        basename: () => ec.psqlBasename(),
        // deno-lint-ignore require-await
        content: async () => {
          return {
            provenance,
            text: psqlText.SQL(ec.sqlEmitContext()),
          };
        },
      };

    return {
      psqlText,
      provenance,
      persistableSQL,
    };
  }

  static init() {
    return new PgDcpEvent();
  }
}

if (import.meta.main) {
  const event = PgDcpEvent.init();
  const content = event.content();
  console.log(content.psqlText.SQL(event.state.ec.sqlEmitContext()));
}
